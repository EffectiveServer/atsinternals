# 引擎与状态机

事件（Event）可以通过三类API（EventProcessor，EThread，Event）丢入这个引擎。

引擎根据事件的类型执行不同的策略，通过调用Event->Cont->handleEvent来驱动状态机（SM）。

状态机完成一个状态的处理，就要迅速返回引擎（EDE）。

这个引擎就如同汽车的发动机一样，每一个点火冲程，都会让轮子转一下，空调压缩机制冷一下。

但是唯一的一点小区别是：
- 这个引擎每次点火只能驱动一个功能
- 这一次是轮子转一下
- 下一次是空调压缩机制冷，等等。

但是引擎只有一个驱动轴，所以轮子转完，就要让出位置，让驱动轴可以再带动其它的部件的运行。

但是很多时候只转一下轮子车子无法到达目的地，只有不断的转动轮子才能到达目的地。

如果引擎只带动轮子转动，就没法驱动空调，那么乘客就会抱怨。

因此我们需要有司机控制，如果还没有达到目的地，就要不断踩油门，让引擎轮流驱动轮子和空调。

因此在为这个引擎设计部件时，必须采用状态机（SM）的设计模式：
- 让轮子记得我们还没有到达目的地
- 让空调知道还没有达到设定的温度
- 让他们记住上一次的工作进度，然后继续完成之前未完的工作。

我们把一路上的旅程分解成：
- 轮子旋转的圈数
- 空调压缩机压缩的次数

然后把这些要求转换成事件传送到引擎里，这样引擎就会不断通过事件来驱动状态机。

状态机每次驱动轮子转一圈，空调压缩机工作一次，最终完成整个任务，这样每一个部件都可以有均等的机会完成工作。

在后面的章节将要介绍的NetHandler，就是由这个引擎驱动的状态机，这些由引擎驱动的状态机，我们把他们称之为引擎的用户。

为了保证整个系统流畅的运行，就要求每一个引擎的用户不能长时间运行，否则就会导致其它引擎用户不能良好的运行。

如果引擎的用户需要等待一个外部状态，例如等待用户输入等，需要：
- 先返回到引擎
- 等下一次引擎重新驱动状态机
- 然后再检查上次的数据是否已经到达
- 或者外部状态是否已经改变

状态机在运行时必须是无阻塞的，凡是遇到阻塞时必须返回到引擎。
