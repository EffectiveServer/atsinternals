# 引擎与状态机

事件（Event）可以通过三类API（EventProcessor，EThread，Event）放入这个引擎：

  - EventProcessor
    - 创建一个 Event，将状态机（SM）包含进去
    - 然后，按照轮询算法从引擎里找到一个 EThread
    - 把 Event 交给这个 EThread 处理
  - EThread
    - 直接把一个 Event 交给指定的 EThread 来处理
  - Event
    - 把 Event 交回原来的 EThread 重新处理

引擎根据事件的类型执行不同的策略，通过调用Event->Cont->handleEvent来驱动状态机（SM），状态机就可以完成一个个状态的处理，一旦遇到阻塞的情况，就要暂停运行，并迅速返回到引擎，等待下一次被引擎驱动的时候再继续之前未完成的任务。

这个引擎就如同汽车的发动机一样，每一个点火冲程，都会让轮子转一下，空调压缩机制冷一下。

但是唯一的一点小区别是：

- 这个引擎每次点火只能驱动一个功能
- 这一次是轮子转一下
- 下一次是空调压缩机制冷，等等。

但是引擎只有一个驱动轴，所以轮子转完，就要让出位置，让驱动轴可以再带动其它的部件的运行。

但是很多时候只转一下轮子车子无法到达目的地，只有不断的转动轮子才能到达目的地。

如果引擎只带动轮子转动，就没法驱动空调，那么乘客就会抱怨。

因此我们需要有司机控制，如果还没有达到目的地，就要不断踩油门，让引擎轮流驱动轮子和空调。

因此在为这个引擎设计部件时，必须采用状态机（SM）的设计模式：

- 让轮子记得我们还没有到达目的地
- 让空调知道还没有达到设定的温度
- 让他们记住上一次的工作进度，然后继续完成之前未完的工作。

我们把一路上的旅程分解成：

- 轮子旋转的圈数
- 空调压缩机压缩的次数

然后把这些要求转换成事件传送到引擎里，这样引擎就会不断通过事件来驱动状态机。

状态机每次驱动轮子转一圈，空调压缩机工作一次，最终完成整个任务，这样每一个部件都可以有均等的机会完成工作。

在后面的章节将要介绍的NetHandler，就是由这个引擎驱动的状态机，这些由引擎驱动的状态机，我们把他们称之为引擎的用户。

为了保证整个系统流畅的运行，就要求每一个引擎的用户不能长时间运行，否则就会导致其它引擎用户不能良好的运行。

如果引擎的用户需要等待一个外部状态（阻塞），例如等待用户输入等，需要：

- 先返回到引擎
- 等下一次引擎重新驱动状态机
- 然后再检查上次的数据是否已经到达
- 或者外部状态是否已经改变

状态机在运行时必须是无阻塞的，凡是遇到阻塞时必须返回到引擎。

这跟我们停车之后，要挂空挡是一个道理，要让出引擎的驱动力给其它需要的组件，否则引擎就会熄火。

状态机在运行时不能出现循环状态，例如：

- 车内空气温度低于22度？
- No, 空调制冷运行一次, 回到第一行
- Yes, 重新调度该状态机在一分钟之后再运行, 返回

上面这个状态机的流程就是一种循环，但是整个运行过程没有阻塞。

这样的设计，让空调得到了最大化的运行效率，但是却让其它的系统全部都停止运行。这样的设计是不符合引擎用户设计要求的，正确的设计应该是：

- 车内空气温度低于22度？
- No, 空调制冷运行一次, 重新调度该状态机立即再次运行, 返回
- Yes, 重新调度该状态机在一分钟之后再运行, 返回
 
 这样的设计，让状态机每一次被引擎回调的时候，只进行一次制冷（有限运行），然后通过 Event 通知引擎：这个状态机还需要再次被驱动。
 这样引擎就会在下一次驱动力分配中再次驱动这个状态机，这样就实现了制冷状态机的反复执行，直到车内温度达标。
 
 然后，每分钟再调用制冷状态机检查车内温度。
